<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        >

        <TextView
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:text="Q1 Activity生命周期"
            android:paddingLeft="15dp"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="running->当前显示在屏幕的activity(位于任务栈的顶部)，用户可见状态。
            \npaused->依旧在用户可见状态，但是界面焦点已经失去，此Activity无法与用户进行交互。
            \nstopped->用户看不到当前界面,也无法与用户进行交互 完全被覆盖.
            \nkilled->当前界面被销毁，等待这系统被回收
            \n
            \n1 Starting ——–>Running 所执行的生命周期顺序 onCreate()->onstart()->onResume()
            \n2 Running ——>Paused 所执行Activity生命周期中的onPause()
            \n3 Paused ——>Running所执行的生命周期为:onResume()
            \n4 Paused ——>Stoped所执行的生命周期为:onStop()
            \n5 Stoped——>Killed所执行的生命周期为:onDestroy()
            \n"
            >
        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="当AActivity切换BActivity的所执行的方法：
            \nAActivity:onCreate()->onStart()->onResume()->onPause()
            \nBActivity:onCreate()->onStart()->onResume()
            \nAActivity:onStop()->onDestory()\n当AActivity切换BActivity（此activity是以dialog形式存在的）所执行的方法:
            \nAActivity:onCreate()->onStart()->onResume()->onPause()
            \nBActivity:onCreate()->onStart()->onResume()"
            >


        </TextView>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@drawable/acitivity_life"
            android:scaleType="fitXY"
            android:adjustViewBounds="true"
            >

        </ImageView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:minHeight="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q2 onSaveInstanceState()和onRestoreInstanceState()"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="onSaveInstanceState函数在Activity生命周期中执行。
            \noutState 参数作用 :
            \n数据保存 : Activity 声明周期结束的时候, 需要保存 Activity 状态的时候, 会将要保存的数据使用键值对的形式 保存在 Bundle 对象中;
            \n调用时机 :Activity 被销毁的时候调用, 也可能没有销毁就调用了;
            \n按下Home键 : Activity 进入了后台, 此时会调用该方法;
            \n按下电源键 : 屏幕关闭, Activity 进入后台;
            \n启动其它 Activity : Activity 被压入了任务栈的栈底;
            \n横竖屏切换 : 会销毁当前 Activity 并重新创建；
            \nonSaveInstanceState方法调用注意事项 :
            \n用户主动销毁不会调用 : 当用户点击回退键 或者 调用了 finish() 方法, 不会调用该方法;
            \n调用时机不固定 : 该方法一定是在 onStop() 方法之前调用, 但是不确定是在 onPause() 方法之前 还是 之后调用;
            \n布局中组件状态存储 : 每个组件都 实现了 onSaveInstance() 方法, 在调用函数的时候, 会自动保存组件的状态, 注意, 只有有 id 的组件才会保存;
            \n关于默认的 super.onSaveInstanceState(outState) : 该默认的方法是实现 组件状态保存的;
            \nonRestoreInstanceState(Bundle outState):
            \n方法回调时机 : 在 Activity 被系统销毁之后 恢复 Activity 时被调用, 只有销毁了之后重建的时候才调用, 如果内存充足, 系统没有销毁这个 Activity, 就不需要调用;
            \nBundle 对象传递 : 该方法保存的 Bundle 对象在 Activity 恢复的时候也会通过参数传递到 onCreate() 方法中;"
            >


        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q3 Activity的启动模式和使用场景"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="1 Standard(默认模式)
            \n每次启动时都会创建一个新的实例
            \n2 SingleTop(栈顶模式)
            \n当启动Activity时,若该Activity位于栈顶,也就是正在前台与用户交互，那就复用这个Activity不会重新创建，该实例Activity.onNewIntent()方法会被调用.
            \n当启动Activity时,若该Activity位于没有位于栈顶则创建和默认默认模式一样重新创建一个新的实例
            \n3 SingleTask(栈内唯一模式)
            \n在启动activity时，若没有该Activity的实例存在于栈内,则会重新创建该Activity的实例.
            \n在启动activity时，若该栈内存在于该Activity的实例并且位于栈顶,则不会重新创建,而是复用该实例,并且会调用Activity.onNewIntent()方法.
            \n在启动activity时，若该栈内存在于该Activity的实例并且没有位于栈顶，那么这个Activity实例会被置为栈顶，并且移除其上面的所有Activity,并调用Activity.onNewIntent()方法
            \n4 SingleInstance(应用内栈唯一模式)
            \n在启动activity时，若该实例存在则其会被置为栈顶并且调用其 Activity.onNewIntent()方法.
            \n在启动activity时，若该实例不存在,则要启动一个新activity实例,并且会存在于一个单独的任务栈中"
            >


        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:minHeight="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q4 Activity之间传递数据的方式Intent是否有大小限制，如果传递的数据量偏大，有哪些方案？"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="数据应该被限制在1MB之内(1024KB)
            \n解决方法:自定义了一个静态类DataHolder，并且设置setData和getData方法，而且考虑到极端的情况，有可能传递的对象的内存是极其大的，所以为了不造成内存泄漏，我们将要传递的对象构造成一个弱引用保存到该静态类"
            >


        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q5 显示启动和隐式启动"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="1 显示启动
            \nIntent intent = new Intent(MainActivity.this,XianshiActivity.class);
            \nstartActivity(intent);
            \n2 隐式启动
            \nIntent intent = new Intent('com.example.intentmethod.xxx');
            \nstartActivity(intent);"
            >


        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:minHeight="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q5 scheme使用场景,协议格式,如何使用"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="一个普通的 URL 分为几个部分，scheme、host、port、relativePath、query、fragment（定义一个url包含了你定义的scheme，主机名或者域名，端口（可选）路径，查询条件等）
            \nprotocol :// hostname[:port] / path / [;parameters][?query]#fragment
            \nprotocol:协议也就是你定义的scheme
            \nhostname:地址域
            \nport:端口
            \npath:路径
            \nparams:参数
            \n使用场景:
            \nScheme 用于从浏览器或其他应用中启动本应用。也就是说要从其他应用中跳转本应用的界面或者网页跳转本应用打开特定的界面。\n"
            >


        </TextView>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@drawable/scheme"
            android:adjustViewBounds="true"
            android:scaleType="centerCrop"
            >

        </ImageView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:minHeight="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q5 ANR的四种场景"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="ANR出现场景:
            \n1 InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件。
            \n2 BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒。
            \n3 Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。
            \n4 ContentProvider Timeout ：ContentProvider的publish在10s内没进行完。
            \nANR出现原因:1 主线程慢代码 2 主线程IO 3 锁竞争 4 死锁
            \n如何避免ANR
            \n1UI线程尽量只做跟UI相关的工作;
            \n2耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理;
            \n3尽量用Handler来处理UI thread和别的thread之间的交互;
            \n4实在绕不开主线程，可以尝试通过Handler延迟加载;
            \n5广播中如果有耗时操作，建议放在IntentService中去执行，或者通过goAsync() + HandlerThread分发执行"
            >


        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:minHeight="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q6 跨App启动Activity的方式,注意事项"
            >

        </TextView>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@drawable/activity_start_1"
            android:adjustViewBounds="true"
            android:scaleType="centerCrop"
            >

        </ImageView>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@drawable/activity_start_2"
            android:adjustViewBounds="true"
            android:scaleType="centerCrop"
            >

        </ImageView>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@drawable/activity_start_3"
            android:adjustViewBounds="true"
            android:scaleType="centerCrop"
            >

        </ImageView>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@drawable/activity_start_4"
            android:adjustViewBounds="true"
            android:scaleType="centerCrop"
            >

        </ImageView>


        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:minHeight="40dp"
            android:textStyle="bold"
            android:textSize="20sp"
            android:gravity="center_vertical"
            android:background="#11333333"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:text="Q7 有哪些Activity常用的标记位Flags"
            >

        </TextView>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:background="@color/white"
            android:paddingLeft="15dp"
            android:paddingRight="15dp"
            android:textColor="@color/black"
            android:text="@string/question_7"
            >


        </TextView>

    </LinearLayout>

</ScrollView>