<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/white"
    android:orientation="vertical"
    >

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/teal_200"
        >

        <TextView
            android:id="@+id/tv_back"
            android:layout_width="80dp"
            android:layout_height="45dp"
            android:text="返回"
            android:textSize="18sp"
            android:textColor="@color/white"
            android:gravity="center"
            android:layout_centerVertical="true"
            />

        <TextView
            android:id="@+id/tv_test"
            android:layout_width="80dp"
            android:layout_height="45dp"
            android:text="测试"
            android:textSize="18sp"
            android:textColor="@color/white"
            android:layout_centerVertical="true"
            android:layout_alignParentRight="true"
            android:gravity="center"
            />

    </RelativeLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="@color/white"
        />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:orientation="vertical"
            >

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q1 什么是组件化？什么是模块化？"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="组件：App工程上所说的 组件，应该翻译为“Component”，意思是组件、部件、元件。在App工程中，组件是构成业务或者功能模块的基本单位。原则上，组件与组件之间互不依赖。
                \n
                \n模块：模块翻译为“Module”。模块由多个组件构成，它可以实现一个独立的功能，甚至业务。
                \n
                \n组件和模块的关系:
                \n1 组件从业务角度上不能继续拆分，可替换，可复用；
                \n2 模块的定义比较笼统，可以是一个Business业务，可以是技术架构中一个业务，也可以是几个组件构成的小功能。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q2 组件化、模块化解决了什么问题？"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 架构更清晰，实现解耦。
                \n2 单个业务模块单独编译打包，加快编译速度。
                \n3 业务模块间解耦，业务分工明确，开发人员仅专注与自己的业务。
                \n4 多团队间可以并行开发、测试。
                \n5 组件、业务独立更新版本，可回滚，持续集成。
                \n6 避免重复造轮子，节省开发维护成本。
                \n7 降低项目复杂性，提升开发效率。
                \n8 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q3 组件间通信"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 本地广播:更多是用在同一个应用内的不同系统规定的组件进行通信，好处在于：发送的广播只会在自己的APP内传播，不会泄漏给其他的APP，其他APP无法向自己的APP发送广播，不用被其他APP干扰。本地广播好比对讲通信，成本低，效率高，但有个缺点就是两者通信机制全部委托与系统负责，我们无法干预传输途中的任何步骤，不可控制，一般在组件化通信过程中采用比例不高。
                \n
                \n2 进程间的AIDL:这个粒度在于进程，而我们组件化通信过程往往是在线程中，况且AIDL通信也是属于系统级通信，底层以Binder机制，虽说Android提供模板供我们实现，但往往使用者不好理解，交互比较复杂，往往也不适用应用于组件化通信过程中
                \n
                \n3 匿名的内存共享:比如用Sharedpreferences，在处于多线程场景下，往往会线程不安全，这种更多是存储一一些变化很少的信息，比如说组件里的配置信息等等。
                \n
                \n4 Base Module:组件层的模块都依赖于基础层，从而产生第三者联系，这种第三者联系最终会编译在APP Module中，那时将不会有这种隔阂，那么其中的Base Module就是跨越组件化层级的关键，也是模块间信息交流的基础。比较有代表性的组件化开源框架有得到DDComponentForAndroid、阿里Arouter、聚美Router等等。
                \n
                \n5 事件总线"
                >
            </TextView>

            <ImageView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:src="@drawable/base_module"
                android:adjustViewBounds="true"
                >

            </ImageView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q4 ARouter原理(https://www.jianshu.com/p/3447d607e466)"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="在代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和activityClass映射关系的类文件，然后app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据读到内存里(保存在map里)，然后在进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()，当调用ARouter的withString()方法它的内部会调用intent.putExtra(String name, String value)，调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。"
                >
            </TextView>

        </LinearLayout>

    </ScrollView>

</LinearLayout>