<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/white"
    android:orientation="vertical"
    >

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/teal_200"
        >

        <TextView
            android:id="@+id/tv_back"
            android:layout_width="80dp"
            android:layout_height="45dp"
            android:text="返回"
            android:textSize="18sp"
            android:textColor="@color/white"
            android:gravity="center"
            android:layout_centerVertical="true"
            />

        <TextView
            android:id="@+id/tv_test"
            android:layout_width="80dp"
            android:layout_height="45dp"
            android:text="测试"
            android:textSize="18sp"
            android:textColor="@color/white"
            android:layout_centerVertical="true"
            android:layout_alignParentRight="true"
            android:gravity="center"
            />

    </RelativeLayout>


    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="@color/white"
        />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:orientation="vertical"
            >

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q1 线程安全的主要手段有？"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1. synchronized 同步锁
                \n2. ReentrantLock 重入锁
                \n3. volatile 线程可见
                \n4. Atomic 原子类家族，如AtomicInteger、AtomicBoolean等
                \n5. ThreadLocal 本地副本
                \n6. Semaphore 信号量
                \n7. ReadLock/WriteLock 读写锁
                \n8. Concurrent 线程安全的集合类，如ConcurrentHashMap等
                \n9. BlockingQueue 阻塞队列
                \n10. CountDownLatch 计数器"
                >
            </TextView>


            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q2 synchronized 同步锁"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 synchronized关键字为同步锁，可重入锁，可以修饰普通方法、静态方法、代码块，但构造方法和成员变量除外。
                \n2 加在普通方法上的synchronized关键字修饰使用的同步锁的是当前对象，就是调用当前方法的那个对象
                \n3 加在静态方法上面的synchronized关键字使用的锁是当前的类对象作为同步锁
                \n4 必须保证的是多个线程在访问同一共享资源时使用的是同一个锁对象，即唯一的锁对象，才有意义。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q3 synchronized实现原理"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 每个Java对象可以作为同步锁是通过一个 内置锁 或者 监视器锁（Monitor Lock） 的指令来实现的。
                \n2 java每个对象都有一个对象头，对象头中有个部分就是用来存储synchronized关键字锁的。
当线程访问一个同步代码块或者方法时必须得到这把锁，当退出或者抛出异常时会释放这把锁，进入锁释放锁是基于monitor对象来实现同步的，monitor对象主要有两个指令monitorenter（插入到同步代码开始位置）、monitorexit（插入到同步代码结束的时候），JVM会保证每个enter后有exit与之对应，但是可能会有多个exit和同一个enter对应，因为退出的时机不仅仅是方法退出也可能是方法抛出异常。每个对象都有一个monitor与之关联，一旦持有之后，就会处于锁定状态，当线程执行到monitorenter这个指令时，就会尝试获取该对象monitor所有权（尝试获取该对象锁）。
\n3 监视器锁的原理是通过计数器来实现，通过monitorenter和monitorexit指令会在执行的时候让锁计数减1或者加1，每个对象都与一个monitor对象关联，一个monitor的lock锁只能被一个线程在同一时间获得，一个线程在尝试获得与这个对象关联的monitor所有权时只会发生以下三种情况之一：
\n  ①如果这个monitor计数器为0，意味着目前还没有被获得，然后这个线程会立刻获得然后将计数器加1， 其它线程就会知道该monitor已经被持有了，这就是成功获得锁。
\n  ②如果这个线程已经拿到了monitor的所有权，又重入了，计数器就会再加1变成2、3…（可重入原理）
\n  ③如果monitor已经被其它线程持有了，现在去获取就会得到无法获取信号，那么就会进入阻塞状态，直到monitor计数器变为0再去尝试获取锁"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q4 总结synchronized注意事项"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁。
                \n2 每个对象只有一个锁（lock）与之相关联。
                \n3 Synchronized修饰的方法或代码块执行完毕后，同步锁是自动释放的，但是在执行同步代码块的过程中，遇到异常而导致线程终止，锁也会被释放。
                \n4 在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放对象锁，进入对象的等待池。
                \n5 当一个线程开始执行同步代码块时，并不意味着必须以不间断的方式运行，进入同步代码块的线程可以执行Thread.sleep()或执行Thread.yield()方法，此时它并不释放对象锁，只是把运行的机会让给其他的线程。
                \n6 synchronized声明不会被继承，如果一个用synchronized修饰的方法被子类覆盖，那么子类中这个方法不再保持同步，除非用synchronized修饰。
                \n7 加锁对象不能为空，锁是保存在对象中的，为空自然不行。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q5 synchronized缺陷"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 不够灵活，不能手动释放锁，一旦加锁成功就必须一直等待同步代码块全部执行完毕，或者抛出异常。
                \n2 不能中断正在加锁的线程, 相比于Lock
                \n3 不能获取申请锁的结果是否成功，相比于Lock
                \n4 不能做到读写锁分离"
                >
            </TextView>


            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q6 ReentrantLock 重入锁"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="ReentrantLock 是Lock接口的实现类，是同步锁，可重入锁，可重入锁是指支持一个线程内对资源的重复加锁，也就是可以多次调用lock()方法获取锁而不被阻塞，synchronized本身也是可重入锁，只不过ReentrantLock比synchronized控制更灵活更具可操作性，能更加有效的避免死锁。同时ReentrantLock还支持获取锁的公平性和非公平性。
                \n
                \n公平锁： 操作会排一个队按顺序执行，来保证执行顺序。所有进入阻塞的线程排队依次均有机会执行。
                \n不公平锁： 是无序状态允许插队，jvm会自动计算如何处理更快速来调度插队。避免每一个线程都进入阻塞，再唤醒，性能高。因为线程可以插队，导致队列中可能会存在线程饿死的情况，一直得不到锁，一直得不到执行。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q7 volatile"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 可见性：保证在不同线程间可见，当变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，当成员变量值每次发生变化时，又强迫将其变化的值重新写入共享内存。
                \n2 有序性：禁止指令重排序。"
                >
            </TextView>


            <ImageView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:src="@drawable/event01"
                android:adjustViewBounds="true"
                android:visibility="gone"
                >

            </ImageView>



        </LinearLayout>

    </ScrollView>

</LinearLayout>