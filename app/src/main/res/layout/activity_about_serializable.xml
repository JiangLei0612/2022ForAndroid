<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/white"
    android:orientation="vertical"
    >

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/teal_200"
        >

        <TextView
            android:id="@+id/tv_back"
            android:layout_width="80dp"
            android:layout_height="45dp"
            android:text="返回"
            android:textSize="18sp"
            android:textColor="@color/white"
            android:gravity="center"
            android:layout_centerVertical="true"
            />

        <TextView
            android:id="@+id/tv_test"
            android:layout_width="80dp"
            android:layout_height="45dp"
            android:text="测试"
            android:textSize="18sp"
            android:textColor="@color/white"
            android:layout_centerVertical="true"
            android:layout_alignParentRight="true"
            android:gravity="center"
            />

    </RelativeLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="@color/white"
        />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:orientation="vertical"
            >

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q1 什么是序列化？"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="就是一种用来处理对象流的机制,所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作,也可将流化后的对象传输于网络之间。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q2 为什么需要使用序列化和反序列化？"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="1 数据持久化：比如一个电商平台，有数万个用户并发访问的时候会产生数万个session 对象，这个时候内存的压力是很大的。我们可以把session对象序列化到硬盘中,需要时在反序列化，减少内存压力。
                \n2 网络传输：我们将系统拆分成多个服务之后，服务之间传输对象，不管是何种类型的数据，都必须要转成二进制流来传输，接受方收到后再转为数据对象。"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q3 Serializable 和 Parcelable 的区别？"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="Serializable：
                \n1 Serializable 是java的序列化技术，最简单的使用方式为在需要序列化的class增加implements Serializable，并增加一个唯一个序列化id： private static final long serialVersionUID = 1L; 默认方式最好直接设置为1L,因为java  sdk会自动进行hash计算，并生成唯一的UID值。手动设置serialVersionUID的好处是当前class如果改变了成员变量，比如增加或者删除之后，这个UID是不改变的，那么反序列化就不会失败；自动设置则在改变了成员变量之后就会重新计算获得新的UID，从而导致失败。不过，大多数情况下两者都可以。
                \n2 Serializable相对Parcelable而言，好处就是非常简单，只需对需要序列化的类class执行就可以，不需要手动去处理序列化和反序列化的过程，所以常常用于网络请求数据处理，Activity之间传递值的使用。
                \n3 Serializable无法序列化静态变量，使用transient修饰的对象也无法序列化。
                \n4 当一个父类实现序列化，子类自动实现序列化，不需要再显示实现Serializable接口。
                \nParcelable:
                \n1 Parcelable是android特有的序列化API，它的出现是为了解决Serializable在序列化的过程中消耗资源严重的问题，但是因为本身使用需要手动处理序列化和反序列化过程，会与具体的代码绑定，使用较为繁琐，一般只获取内存数据的时候使用。
                \n2 而Parcelable依赖于Parcel,Parcel的意思是包装，实现原理是在内存中建立一块共享数据块，序列化和反序列化均是操作这一块的数据，如此来实现。
                \n3 Parcelable的三个过程：序列化、反序列化和描述"
                >
            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="40dp"
                android:textStyle="bold"
                android:textSize="20sp"
                android:gravity="center_vertical"
                android:background="@color/teal_200"
                android:textColor="@color/white"
                android:text="Q4 什么是serialVersionUID?为什么还要显示指定serialVersionUID的值?"
                android:paddingLeft="15dp"
                >

            </TextView>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:background="@color/white"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:textColor="@color/black"
                android:textIsSelectable="true"
                android:textStyle="bold"
                android:text="对同一个实体序列化反序列化时，需要serialVersionUID值一致才能成功。如果我们不显示指定serialVersionUID，在序列化时会自动生成一个serialVersionUID。当实体类改动了，反序列化时，会生成一个新serialVersionUID。这两个serialVersionUID的值肯定不一致，从而反序列化会失败。但是如果显示指定，就不会生成新serialVersionUID值了。反序列化的serialVersionUID就是原序列化的serialVersionUID。"
                >
            </TextView>


            <ImageView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:paddingLeft="15dp"
                android:paddingRight="15dp"
                android:src="@drawable/event01"
                android:adjustViewBounds="true"
                android:visibility="gone"
                >

            </ImageView>



        </LinearLayout>

    </ScrollView>

</LinearLayout>